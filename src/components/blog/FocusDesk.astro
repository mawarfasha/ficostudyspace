---
import Title from "@components/global/Title.astro";
import { getLangFromUrl, useTranslations } from "@i18n/utils";

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);
---

<!-- Yellow Blob Cursor Follower -->
<div id="cursor-follower" data-xdata="{ isTouchDevice: 'ontouchstart' in window }" data-xshow="!isTouchDevice">
	<div id="blob" class="blob"></div>
</div>

<section>
	<div class="top-[-10rem]transform-gpu absolute inset-x-0 overflow-hidden blur-3xl sm:top-[-20rem]" aria-hidden="true">
		<div class="gradient-element"></div>
	</div>
	<div class="mx-auto flex flex-col gap-16 px-8 py-12 md:px-12 lg:pt-16 2xl:max-w-7xl">
		<!-- svg: first layer -->
		<svg class="hidden" viewBox="0 0 250 250" xmlns="http://www.w3.org/2000/svg">
			<filter id="article-noise-filter">
				<feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"></feTurbulence>
			</filter>
		</svg>
		
		<Title title="Focus Mode" subtitle="Your Digital Study Desk" class="pb-6 pt-8 uppercase" />
		
		<!-- Main Content Area -->
		<div class="grid grid-cols-1 lg:grid-cols-3 gap-8 min-h-[600px]">
			<!-- Focus Monitor & Notes - Left Side (2/3 width) -->
			<div class="lg:col-span-2 space-y-6">
				<!-- Large Camera Feed Section -->
				<div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black text-center">Focus Monitor</h3>
					
					<!-- Camera Display - Much Larger -->
					<div class="relative bg-black/50 rounded-lg overflow-hidden mb-4 aspect-video h-96">
						<video id="cameraFeed" autoplay muted class="w-full h-full object-cover camera-mirrored"></video>
						<div id="cameraPlaceholder" class="absolute inset-0 flex items-center justify-center text-white/60">
							<div class="text-center">
								<svg class="w-24 h-24 mx-auto mb-4" fill="currentColor" viewBox="0 0 20 20">
									<path fill-rule="evenodd" d="M4 5a2 2 0 00-2 2v6a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586l-.707-.707A1 1 0 0013 4H7a1 1 0 00-.707.293L5.586 5H4zm6 9a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path>
								</svg>
								<p class="text-lg">Camera Disabled</p>
							</div>
						</div>
					</div>

					<!-- Compact Camera & Timelapse Controls -->
					<div class="space-y-6 mb-3">
						<!-- Camera Toggle -->
						<button id="toggleCamera" class="w-full squircle-bg rounded-lg bg-zinc-900 text-white transition-all hover:bg-slate-200 hover:text-black py-3 px-4 text-sm font-medium" data-cursor-hover data-cursor-parallax>
						Enable Camera
						</button>
						
						<!-- Timelapse Settings (Compact) -->
						<div class="grid grid-cols-2 gap-3 text-xs mb-6">
							<div>
								<label class="block text-black/70 mb-1">Interval</label>
								<div class="flex items-center gap-2">
									<input type="range" id="intervalSlider" min="100" max="5000" value="1000" 
										class="flex-1 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer">
									<span id="intervalValue" class="text-xs text-black min-w-[35px]">1.0s</span>
								</div>
							</div>
							<div>
								<label class="block text-black/70 mb-1">Speed</label>
								<div class="flex items-center gap-2">
									<input type="range" id="speedSlider" min="5" max="60" value="30" 
										class="flex-1 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer">
									<span id="speedValue" class="text-xs text-black min-w-[35px]">30fps</span>
								</div>
							</div>
						</div>
						
						<!-- Compact Timelapse Controls -->
						<div class="grid grid-cols-3 gap-2">
							<button id="startTimelapse" class="squircle-bg rounded-lg bg-green-600 text-white transition-all hover:bg-slate-200 hover:text-black py-3 px-3 text-sm font-medium" data-cursor-hover data-cursor-parallax disabled>
								‚ñ∂ Start
							</button>
							<button id="stopTimelapse" class="squircle-bg rounded-lg bg-red-600 text-white transition-all hover:bg-slate-200 hover:text-black py-3 px-3 text-sm font-medium" data-cursor-hover data-cursor-parallax disabled>
								‚èπ Stop
							</button>
							<button id="downloadTimelapse" class="squircle-bg rounded-lg bg-blue-600 text-white transition-all hover:bg-slate-200 hover:text-black py-3 px-3 text-sm font-medium" disabled>
								Download
							</button>
						</div>
					</div>
					
					<p class="text-xs text-black/40 text-center">Monitor your focus during study sessions</p>
				</div>

				<!-- Session Notes -->
				<!-- <div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black">Session Notes</h3>
					<textarea 
						placeholder="Take notes during your focus session..."
						class="w-full h-64 bg-white border border-gray-300 rounded-md px-3 py-2 text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
					></textarea>
					<div class="mt-4 flex justify-between items-center">
						<span class="text-sm text-black/60" id="charCount">0 characters</span>
						<button class="squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black px-4 py-2">
							Save Notes
						</button>
					</div>
				</div> -->

				<!-- Study Session Info -->
				<!-- <div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black">Current Session</h3>
					<div class="grid grid-cols-2 gap-4">
						<div>
							<label class="block text-sm font-medium text-black/80 mb-2">Session Type</label>
							<select class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-black focus:outline-none focus:ring-2 focus:ring-blue-500">
								<option value="study">Study Session</option>
								<option value="work">Work Session</option>
								<option value="creative">Creative Work</option>
								<option value="reading">Reading</option>
							</select>
						</div>
						<div>
							<label class="block text-sm font-medium text-black/80 mb-2">Session Goal</label>
							<input type="text" placeholder="e.g., Complete Chapter 3" class="w-full bg-white border border-gray-300 rounded-md px-3 py-2 text-black placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500">
						</div>
					</div>
				</div> -->
			</div>

			<!-- Right Sidebar - Timer & Controls (1/3 width) -->
			<div class="space-y-6">
				<!-- Timer Section -->
				<div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black text-center">Focus Timer</h3>
					
					<!-- Timer Display -->
					<div class="text-center mb-6">
						<div class="relative inline-block mb-2">
							<div class="text-4xl font-mono font-bold text-black" id="timerDisplay">25:00</div>
							<div class="absolute top-1/2 -translate-y-1/2 flex flex-col gap-1" style="left: 100%; margin-left: 4px;">
								<button id="timerUpBtn" class="w-4 h-3 flex items-center justify-center text-black hover:text-gray-600 transition-colors cursor-pointer" style="font-size: 6px;">
									‚ñ≤
								</button>
								<button id="timerDownBtn" class="w-4 h-3 flex items-center justify-center text-black hover:text-gray-600 transition-colors cursor-pointer" style="font-size: 6px;">
									‚ñº
								</button>
							</div>
						</div>
						<div class="text-sm text-black/60" id="timerStatus">Ready to start</div>
					</div>

					<!-- Timer Presets -->
					<div class="grid grid-cols-3 gap-2 mb-4">
						<button class="preset-btn squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-2 text-sm" data-minutes="25">
							25m
						</button>
						<button class="preset-btn squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-2 text-sm" data-minutes="45">
							45m
						</button>
						<button class="preset-btn squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-2 text-sm" data-minutes="60">
							60m
						</button>
					</div>

					<!-- Timer Controls -->
					<div class="space-y-2">
						<button id="startBtn" class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4" data-cursor-hover data-cursor-parallax>
							Start
						</button>
						<button id="pauseBtn" class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4" data-cursor-hover data-cursor-parallax disabled>
							Pause
						</button>
						<button id="resetBtn" class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4" data-cursor-hover data-cursor-parallax>
							Reset
						</button>
						<div class="text-xs text-black/60 text-center" style="margin-top: 1rem; margin-bottom: 0.3rem;">
							Save current progress?
						</div>
						<button id="stopBtn" class="w-full squircle-bg rounded-lg bg-red-600 text-white transition-all hover:bg-slate-200 hover:text-black py-2 px-4" data-cursor-hover data-cursor-parallax disabled>
							Stop & Save Progress
						</button>
					</div>
				</div>

				<!-- Session Stats -->
				<div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black">Today's Progress</h3>
					<div class="space-y-4">
						<div class="text-center">
							<div class="text-2xl font-bold text-black" id="sessionsCompleted">0</div>
							<div class="text-sm text-black/60">Sessions Today</div>
						</div>
						<div class="text-center">
							<div class="text-2xl font-bold text-black" id="totalFocusTime">0m</div>
							<div class="text-sm text-black/60">Focus Time Today</div>
						</div>
						<div class="text-center">
							<div class="text-2xl font-bold text-black" id="currentStreak">0</div>
							<div class="text-sm text-black/60">Day Streak</div>
						</div>
					</div>
				</div>

				<!-- Quick Actions -->
				<!-- <div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
					<h3 class="text-xl font-semibold mb-4 text-black text-center">Quick Actions</h3>
					<div class="space-y-2">
						<button class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4">
							Break Time
						</button>
						<button class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4">
							Background Sounds
						</button>
						<button class="w-full squircle-bg rounded-lg bg-zinc-900 text-slate-200 transition-all hover:bg-slate-200 hover:text-black py-2 px-4">
							Do Not Disturb
						</button>
					</div>
				</div> -->
			</div>
		</div>
		
		<!-- Recordings Section -->
		<div class="-mt-8">
			<div class="bg-white/90 backdrop-blur-md rounded-lg p-6 border border-gray/20">
				<h3 class="text-xl font-semibold mb-4 text-black text-center">Recent Time-lapses</h3>
				<div id="recordingsList" class="space-y-4">
					<p class="text-center text-black/60 py-8">
						No recordings yet. Start your first time-lapse!
					</p>
				</div>
			</div>
		</div>
	</div>
</section>

<style>
	.gradient-element {
		@apply relative left-1/2 -z-10 aspect-[1155/678] w-[36.125rem] max-w-none -translate-x-1/2 rotate-[30deg] bg-gradient-to-tr from-[#a2d4a0] to-[#aac887] opacity-30 sm:left-[calc(50%-40rem)] sm:w-[72.1875rem];
		clip-path: polygon(
			74.1% 44.1%,
			100% 61.6%,
			97.5% 26.9%,
			85.5% 0.1%,
			80.7% 2%,
			72.5% 32.5%,
			60.2% 62.4%,
			52.4% 68.1%,
			47.5% 58.3%,
			45.2% 34.5%,
			27.5% 76.7%,
			0.1% 64.9%,
			17.9% 100%,
			27.6% 76.8%,
			76.1% 97.7%,
			74.1% 44.1%
		);
	}

	/* Yellow Blob Cursor Follower Styles */
	#cursor-follower {
		position: fixed;
		top: 0;
		left: 0;
		opacity: 0;
		height: 100vh;
		width: 100vw;
		transition: opacity 0.2s ease-in-out 1s;
		pointer-events: none;
		z-index: 10;
	}

	@keyframes fadeIn {
		0% {
			opacity: 0;
		}
		100% {
			opacity: 1;
		}
	}

	#cursor-follower.active {
		animation: fadeIn 2s forwards;
	}

	#blob {
		position: fixed;
		border-radius: 50px;
		filter: blur(50px);
		opacity: 0.2;
		top: 0;
		left: 0;
		height: 200px;
		width: 200px;
		background-color: #edb74d;
		transform: scale(0.5) translate(-50%, -50%);
		pointer-events: none;
		will-change: transform;
	}

	/* Camera mirroring */
	.camera-mirrored {
		transform: scaleX(-1);
	}
</style>

<script is:inline>
	// Yellow Blob Cursor Follower functionality
	function initBlobCursor() {
		const isTouchDevice = window.matchMedia("(hover: none)").matches;
		if (isTouchDevice) return;

		var mouse = { x: 0, y: 0 };
		var pos = { x: 0, y: 0 };
		var ratio = 0.65;
		var blob = document.getElementById("blob");
		var magicCursor = document.getElementById("cursor-follower");

		if (!blob || !magicCursor) {
			console.log('Blob elements not found:', { blob: !!blob, magicCursor: !!magicCursor });
			return;
		}

		console.log('Initializing blob cursor...');

		// Set initial position
		blob.style.transform = 'translate(-50%, -50%)';

		document.addEventListener("mousemove", mouseMove);

		function updatePosition() {
			pos.x += (mouse.x - pos.x) * ratio;
			pos.y += (mouse.y - pos.y) * ratio;
			blob.style.transform = `translate(${pos.x}px, ${pos.y}px) translate(-50%, -50%)`;
		}

		function mouseMove(e) {
			var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
			mouse.x = e.pageX;
			mouse.y = e.pageY - scrollTop;
		}

		// Use requestAnimationFrame instead of GSAP ticker
		function animate() {
			updatePosition();
			requestAnimationFrame(animate);
		}
		animate();

		// Add hover effects for interactive elements
		let parallaxWraps = document.querySelectorAll("[data-cursor-hover]");
		console.log('Found hover elements:', parallaxWraps.length);
		
		parallaxWraps.forEach(function (wrap) {
			wrap.addEventListener("mouseenter", function (e) {
				blob.style.opacity = '0.5';
				blob.style.transition = 'opacity 0.5s ease';
			});

			wrap.addEventListener("mouseleave", function (e) {
				blob.style.opacity = '0.2';
				blob.style.transition = 'opacity 0.5s ease';
				
				if (wrap && wrap.hasAttribute("data-cursor-parallax")) {
					wrap.style.transform = 'scale(1) translate(0px, 0px)';
					wrap.style.transition = 'transform 0.3s ease';
				}
			});

			wrap.addEventListener("mousemove", function (e) {
				if (wrap && wrap.hasAttribute("data-cursor-parallax")) {
					var boundingRect = wrap.getBoundingClientRect();
					var relX = e.pageX - boundingRect.left;
					var relY = e.pageY - boundingRect.top;
					var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
					
					var movement = 10;
					var x = ((relX - boundingRect.width / 2) / boundingRect.width) * movement;
					var y = ((relY - boundingRect.height / 2 - scrollTop) / boundingRect.height) * movement;
					
					wrap.style.transform = `translate(${x}px, ${y}px)`;
					wrap.style.transition = 'transform 0.3s ease';
				}
			});
		});

		magicCursor.classList.add("active");
		console.log('Blob cursor initialized successfully');
	}

	// Plain JavaScript implementation for better Astro compatibility
	class TimeLapseRecorder {
		constructor() {
			console.log('TimeLapseRecorder constructor starting...');
			
			// DOM elements
			this.video = document.getElementById('cameraFeed');
			this.startBtn = document.getElementById('startTimelapse');
			this.stopBtn = document.getElementById('stopTimelapse');
			this.downloadBtn = document.getElementById('downloadTimelapse');
			this.toggleCameraBtn = document.getElementById('toggleCamera');
			this.intervalSlider = document.getElementById('intervalSlider');
			this.speedSlider = document.getElementById('speedSlider');
			this.intervalValue = document.getElementById('intervalValue');
			this.speedValue = document.getElementById('speedValue');
			this.recordingsList = document.getElementById('recordingsList');
			this.cameraPlaceholder = document.getElementById('cameraPlaceholder');

			console.log('Elements found:', {
				video: !!this.video,
				startBtn: !!this.startBtn,
				stopBtn: !!this.stopBtn,
				downloadBtn: !!this.downloadBtn,
				toggleCameraBtn: !!this.toggleCameraBtn,
				intervalSlider: !!this.intervalSlider,
				speedSlider: !!this.speedSlider
			});

			// State
			this.mediaRecorder = null;
			this.stream = null;
			this.canvas = document.createElement('canvas');
			this.ctx = this.canvas.getContext('2d');
			this.frames = [];
			this.isRecording = false;
			this.captureInterval = null;
			this.recordings = [];
			this.cameraEnabled = false;

			this.init();
		}

		async init() {
			console.log('Initializing TimeLapseRecorder...');
			console.log('Environment check:', {
				protocol: window.location.protocol,
				hostname: window.location.hostname,
				isSecureContext: window.isSecureContext,
				hasGetUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
			});
			
			// Wait for DOM to be fully ready
			const initializeComponents = () => {
				console.log('DOM ready, setting up TimeLapse components...');
				this.setupEventListeners();
				this.loadRecordings(); // Load saved recordings
				this.updateUI(); // Enable buttons initially
				this.updateStatus('Camera Ready - Click "Enable Camera" to start');
				
				// Force enable camera button with multiple methods
				if (this.toggleCameraBtn) {
					this.toggleCameraBtn.disabled = false;
					this.toggleCameraBtn.removeAttribute('disabled');
					this.toggleCameraBtn.style.pointerEvents = 'auto';
					this.toggleCameraBtn.style.opacity = '1';
					this.toggleCameraBtn.style.cursor = 'pointer';
					console.log('Camera button forcefully enabled. Current state:', {
						disabled: this.toggleCameraBtn.disabled,
						hasDisabledAttr: this.toggleCameraBtn.hasAttribute('disabled'),
						style: this.toggleCameraBtn.style.cssText,
						classList: this.toggleCameraBtn.className
					});
				} else {
					console.error('toggleCamera button not found during initialization!');
				}
			};
			
			// Use a small delay to ensure DOM is ready
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initializeComponents);
			} else {
				setTimeout(initializeComponents, 100);
			}
		}

		setupEventListeners() {
			console.log('Setting up event listeners...');
			
			if (this.toggleCameraBtn) {
				console.log('Adding click listener to toggleCamera button');
				
				// Remove any existing listeners first
				this.toggleCameraBtn.removeEventListener('click', this.handleToggleCamera);
				
				// Create bound method to maintain context
				this.handleToggleCamera = (e) => {
					e.preventDefault();
					e.stopPropagation();
					console.log('Toggle camera clicked - event triggered');
					this.toggleCamera();
				};
				
				// Add the event listener
				this.toggleCameraBtn.addEventListener('click', this.handleToggleCamera);
				
				// Also try using mousedown as backup
				this.toggleCameraBtn.addEventListener('mousedown', (e) => {
					console.log('Camera button mousedown detected');
				});
				
				console.log('Event listener attached successfully');
			} else {
				console.error('toggleCamera button not found during event listener setup!');
			}

			if (this.startBtn) {
				this.startBtn.addEventListener('click', () => {
					console.log('Start timelapse clicked');
					this.startRecording();
				});
			}

			if (this.stopBtn) {
				this.stopBtn.addEventListener('click', () => {
					console.log('Stop timelapse clicked');
					this.stopRecording();
				});
			}

			if (this.downloadBtn) {
				this.downloadBtn.addEventListener('click', () => {
					console.log('Download clicked');
					this.downloadLatest();
				});
			}

			if (this.intervalSlider) {
				this.intervalSlider.addEventListener('input', (e) => {
					const value = parseInt(e.target.value);
					if (this.intervalValue) {
						this.intervalValue.textContent = (value / 1000).toFixed(1) + 's';
					}
				});
			}

			if (this.speedSlider) {
				this.speedSlider.addEventListener('input', (e) => {
					const value = parseInt(e.target.value);
					if (this.speedValue) {
						this.speedValue.textContent = value + ' FPS';
					}
				});
			}
		}

		async toggleCamera() {
			console.log('toggleCamera called, cameraEnabled:', this.cameraEnabled);
			
			// Check if we're in a secure context
			if (!window.isSecureContext) {
				console.error('Camera access requires HTTPS (secure context)');
				this.updateStatus('‚ùå Camera requires HTTPS. Please access via https://');
				if (this.cameraPlaceholder) {
					this.cameraPlaceholder.innerHTML = '<div class="text-center"><p class="text-lg text-red-500">Camera access requires HTTPS<br>Please access via https://</p></div>';
					this.cameraPlaceholder.style.display = 'flex';
				}
				return;
			}

			// Check if getUserMedia is supported
			if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
				console.error('getUserMedia not supported');
				this.updateStatus('‚ùå Camera not supported in this browser');
				if (this.cameraPlaceholder) {
					this.cameraPlaceholder.innerHTML = '<div class="text-center"><p class="text-lg text-red-500">Camera not supported<br>Please use a modern browser</p></div>';
					this.cameraPlaceholder.style.display = 'flex';
				}
				return;
			}
			
			if (!this.cameraEnabled) {
				try {
					console.log('Requesting camera access...');
					console.log('Current URL protocol:', window.location.protocol);
					console.log('Is secure context:', window.isSecureContext);
					
					this.stream = await navigator.mediaDevices.getUserMedia({
						video: { 
							width: { ideal: 1280 }, 
							height: { ideal: 720 },
							facingMode: 'user'
						},
						audio: false
					});
					
					console.log('Camera access granted');
					
					if (this.video) {
						this.video.srcObject = this.stream;
						this.video.style.display = 'block';
					}
					
					if (this.cameraPlaceholder) {
						this.cameraPlaceholder.style.display = 'none';
					}
					
					if (this.toggleCameraBtn) {
						this.toggleCameraBtn.textContent = 'Disable Camera';
						this.toggleCameraBtn.className = this.toggleCameraBtn.className.replace('bg-zinc-900', 'bg-red-600');
					}
					
					this.cameraEnabled = true;
					this.updateUI();
					this.updateStatus('‚úÖ Camera connected successfully!');
					
				} catch (error) {
					console.error('Camera access error:', error);
					console.error('Error name:', error.name);
					console.error('Error message:', error.message);
					
					let errorMessage = '‚ùå Camera access failed: ';
					let htmlMessage = '<div class="text-center"><p class="text-lg text-red-500">';
					
					switch (error.name) {
						case 'NotAllowedError':
							errorMessage += 'Permission denied. Please allow camera access.';
							htmlMessage += 'Camera permission denied<br>Please click allow when prompted or check browser settings</p></div>';
							break;
						case 'NotFoundError':
							errorMessage += 'No camera found on this device.';
							htmlMessage += 'No camera found<br>Please connect a camera device</p></div>';
							break;
						case 'NotSupportedError':
							errorMessage += 'Camera not supported in this browser.';
							htmlMessage += 'Camera not supported<br>Please use Chrome, Firefox, or Safari</p></div>';
							break;
						case 'NotReadableError':
							errorMessage += 'Camera is already in use by another application.';
							htmlMessage += 'Camera in use<br>Please close other apps using the camera</p></div>';
							break;
						case 'SecurityError':
							errorMessage += 'Security error. Please ensure you\'re using HTTPS.';
							htmlMessage += 'Security error - HTTPS required<br>Please access via https://</p></div>';
							break;
						default:
							errorMessage += error.message || 'Unknown error occurred.';
							htmlMessage += `Camera error<br>${error.message || 'Please try again'}</p></div>`;
							break;
					}
					
					this.updateStatus(errorMessage);
					if (this.cameraPlaceholder) {
						this.cameraPlaceholder.innerHTML = htmlMessage;
						this.cameraPlaceholder.style.display = 'flex';
					}
				}
			} else {
				console.log('Disabling camera...');
				// Disable camera
				if (this.stream) {
					this.stream.getTracks().forEach(track => track.stop());
					this.stream = null;
				}
				
				if (this.video) {
					this.video.style.display = 'none';
				}
				
				if (this.cameraPlaceholder) {
					this.cameraPlaceholder.style.display = 'flex';
				}
				
				if (this.toggleCameraBtn) {
					this.toggleCameraBtn.textContent = 'Enable Camera';
					this.toggleCameraBtn.className = this.toggleCameraBtn.className.replace('bg-red-600', 'bg-zinc-900');
				}
				
				this.cameraEnabled = false;
				
				// Stop recording if active
				if (this.isRecording) {
					this.stopRecording();
				}
				
				this.updateUI();
				this.updateStatus('üì∑ Camera disabled');
			}
		}

		startRecording() {
			console.log('startRecording called');
			if (this.isRecording || !this.cameraEnabled) {
				console.log('Cannot start - isRecording:', this.isRecording, 'cameraEnabled:', this.cameraEnabled);
				return;
			}

			this.isRecording = true;
			this.frames = [];
			const interval = this.intervalSlider ? parseInt(this.intervalSlider.value) : 1000;

			if (this.video && this.ctx) {
				this.canvas.width = this.video.videoWidth;
				this.canvas.height = this.video.videoHeight;

				this.captureInterval = setInterval(() => {
					this.captureFrame();
				}, interval);

				this.updateUI();
				this.updateStatus(`üé¨ Recording started! Capturing every ${(interval/1000).toFixed(1)}s`);
			}
		}

		captureFrame() {
			if (!this.isRecording || !this.ctx || !this.video) return;

			// Save the context state
			this.ctx.save();
			
			// Mirror the image horizontally (flip)
			this.ctx.scale(-1, 1);
			this.ctx.drawImage(this.video, -this.canvas.width, 0, this.canvas.width, this.canvas.height);
			
			// Restore the context state
			this.ctx.restore();
			
			const frameData = this.canvas.toDataURL('image/jpeg', 0.8);
			this.frames.push(frameData);
			
			// Update start button text with frame count
			if (this.startBtn) {
				this.startBtn.textContent = `üî¥ Recording... (${this.frames.length} frames)`;
			}
			
			this.updateStatus(`üì∏ Recording... ${this.frames.length} frames captured`);
		}

		async stopRecording() {
			console.log('stopRecording called');
			if (!this.isRecording) return;

			this.isRecording = false;
			if (this.captureInterval) {
				clearInterval(this.captureInterval);
			}

			if (this.frames.length === 0) {
				this.updateStatus('‚ö†Ô∏è No frames captured. Try recording for a longer duration.');
				this.updateUI();
				return;
			}

			this.updateStatus('‚è≥ Processing time-lapse video...');
			await this.createTimeLapse();
			this.updateUI();
		}

		async createTimeLapse() {
			console.log('createTimeLapse called');
			return new Promise((resolve) => {
				const fps = this.speedSlider ? parseInt(this.speedSlider.value) : 30;
				const frameDuration = 1000 / fps;

				if (!this.ctx) {
					resolve();
					return;
				}

				const mediaRecorder = new MediaRecorder(this.canvas.captureStream(fps), {
					mimeType: 'video/webm'
				});

				const chunks = [];
				mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
				mediaRecorder.onstop = () => {
					const blob = new Blob(chunks, { type: 'video/webm' });
					const url = URL.createObjectURL(blob);
					
					const recording = {
						id: Date.now(),
						url: url,
						blob: blob,
						timestamp: new Date(),
						frameCount: this.frames.length,
						fps: fps,
						duration: (this.frames.length / fps).toFixed(1)
					};

					this.recordings.unshift(recording);
					this.saveRecordings(); // Save to localStorage
					this.updateRecordingsList();
					this.updateStatus(`‚ú® Time-lapse created! ${this.frames.length} frames at ${fps}fps`);
					
					// Show completion popup with download option
					this.showCompletionPopup(recording);
					
					resolve();
				};

				mediaRecorder.start();

				let frameIndex = 0;
				const playFrames = () => {
					if (frameIndex < this.frames.length && this.ctx) {
						const img = new Image();
						img.onload = () => {
							if (this.ctx) {
								this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
								
								// Since frames are already mirrored when captured, draw them normally
								this.ctx.drawImage(img, 0, 0);
								frameIndex++;
								setTimeout(playFrames, frameDuration);
							}
						};
						img.src = this.frames[frameIndex];
					} else {
						mediaRecorder.stop();
					}
				};

				setTimeout(playFrames, 100);
			});
		}

		updateRecordingsList() {
			if (!this.recordingsList) return;

			if (this.recordings.length === 0) {
				this.recordingsList.innerHTML = `
					<p class="text-center text-black/60 py-8">
						No recordings yet. Start your first time-lapse above! üé•
					</p>
				`;
				return;
			}

			// Check if we have any recordings from previous sessions
			const hasPreviousSessionRecordings = this.recordings.some(r => r.fromPreviousSession);
			
			let clearButton = '';
			if (hasPreviousSessionRecordings) {
				clearButton = `
					<div class="mb-4 text-center">
						<button onclick="timeLapse.clearHistory()" 
								class="px-4 py-2 bg-gray-600 text-white rounded text-sm hover:bg-gray-700 transition-colors">
							üóëÔ∏è Clear Session History
						</button>
						<p class="text-xs text-black/60 mt-1">Remove recordings from previous sessions</p>
					</div>
				`;
			}

			const recordingsHtml = this.recordings.map(recording => {
				const hasVideo = recording.url ? true : false;
				const isExpired = recording.isExpired || false;
				
				const videoElement = hasVideo 
					? `<video class="w-20 h-15 rounded object-cover" src="${recording.url}" muted loop autoplay></video>`
					: `<div class="w-20 h-15 rounded bg-gray-300 flex items-center justify-center">
						<svg class="w-8 h-8 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
							<path d="M2 6a2 2 0 012-2h6l2 2h6a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM5 8a1 1 0 000 2h8a1 1 0 100-2H5z"></path>
						</svg>
					</div>`;

				const downloadButton = hasVideo 
					? `<button onclick="timeLapse.downloadRecording(${recording.id})" 
							class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-slate-200 hover:text-black">
						üíæ Download
					</button>`
					: `<button disabled class="px-3 py-1 bg-gray-400 text-white rounded text-sm cursor-not-allowed">
						üíæ Not Available
					</button>`;

				const playButton = hasVideo 
					? `<button onclick="timeLapse.playRecording(${recording.id})" 
							class="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-slate-200 hover:text-black">
						‚ñ∂Ô∏è Play
					</button>`
					: `<button disabled class="px-3 py-1 bg-gray-400 text-white rounded text-sm cursor-not-allowed">
						‚ñ∂Ô∏è Not Available
					</button>`;

				// Determine the status message
				let statusMessage = '';
				if (recording.fromPreviousSession) {
					statusMessage = '<br><span class="text-blue-600">üìã Recording info from previous session</span>';
				} else if (isExpired) {
					statusMessage = '<br><span class="text-red-600">‚è∞ Expired (older than 3 days)</span>';
				} else if (!hasVideo) {
					statusMessage = '<br><span class="text-orange-600">‚ö†Ô∏è Video not available (from previous session)</span>';
				}

				return `
					<div class="flex items-center gap-4 p-4 bg-white/50 rounded-lg border border-gray-200 ${isExpired ? 'opacity-75' : ''}">
						${videoElement}
						<div class="flex-1">
							<div class="font-semibold text-black">Time-lapse ${recording.id}</div>
							<div class="text-sm text-black/60">
								${recording.frameCount} frames ‚Ä¢ ${recording.fps}fps ‚Ä¢ ${recording.duration}s<br>
								Created: ${recording.timestamp.toLocaleString()}
								${statusMessage}
							</div>
						</div>
						<div class="flex gap-2">
							${downloadButton}
							${playButton}
							<button onclick="timeLapse.deleteRecording(${recording.id})" 
									class="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-slate-200 hover:text-black">
								üóëÔ∏è Delete
							</button>
						</div>
					</div>
				`;
			}).join('');

			this.recordingsList.innerHTML = clearButton + recordingsHtml;
		}

		downloadRecording(id) {
			const recording = this.recordings.find(r => r.id === id);
			if (!recording) return;

			const a = document.createElement('a');
			a.href = recording.url;
			a.download = `timelapse-${recording.id}.webm`;
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
		}

		playRecording(id) {
			const recording = this.recordings.find(r => r.id === id);
			if (!recording) return;

			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed; top: 0; left: 0; width: 100%; height: 100%;
				background: rgba(0,0,0,0.9); display: flex; align-items: center;
				justify-content: center; z-index: 1000; backdrop-filter: blur(5px);
			`;
			
			modal.innerHTML = `
				<div style="max-width: 90%; max-height: 90%; position: relative;">
					<video controls autoplay style="width: 100%; height: auto; border-radius: 10px; max-height: 80vh;">
						<source src="${recording.url}" type="video/webm">
					</video>
					<button onclick="this.parentElement.parentElement.remove()" 
							style="position: absolute; top: -40px; right: 0; background: white; 
								   border: none; border-radius: 50%; width: 30px; height: 30px; 
								   cursor: pointer; font-size: 18px; font-weight: bold;">√ó</button>
					<div style="color: white; text-align: center; margin-top: 10px; font-size: 14px;">
						${recording.frameCount} frames ‚Ä¢ ${recording.fps}fps ‚Ä¢ ${recording.duration}s
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			modal.addEventListener('click', (e) => {
				if (e.target === modal) modal.remove();
			});
		}

		downloadLatest() {
			console.log('downloadLatest called');
			if (this.recordings.length > 0) {
				this.downloadRecording(this.recordings[0].id);
			}
		}

		updateUI() {
			console.log('updateUI called');
			
			// Enable camera toggle button - this should always be enabled
			if (this.toggleCameraBtn) {
				this.toggleCameraBtn.disabled = false;
				this.toggleCameraBtn.removeAttribute('disabled');
				console.log('Camera button enabled');
			}
			
			// Enable/disable timelapse start button
			if (this.startBtn) {
				const shouldDisable = this.isRecording || !this.cameraEnabled;
				this.startBtn.disabled = shouldDisable;
				if (shouldDisable) {
					this.startBtn.setAttribute('disabled', 'true');
				} else {
					this.startBtn.removeAttribute('disabled');
				}
				if (!this.isRecording) {
					this.startBtn.textContent = '‚ñ∂ Start';
				}
				console.log('Start button state - disabled:', shouldDisable);
			}
			
			// Enable/disable timelapse stop button
			if (this.stopBtn) {
				const shouldDisable = !this.isRecording;
				this.stopBtn.disabled = shouldDisable;
				if (shouldDisable) {
					this.stopBtn.setAttribute('disabled', 'true');
				} else {
					this.stopBtn.removeAttribute('disabled');
				}
				console.log('Stop button state - disabled:', shouldDisable);
			}
			
			// Enable/disable download button
			if (this.downloadBtn) {
				const shouldDisable = this.recordings.length === 0;
				this.downloadBtn.disabled = shouldDisable;
				if (shouldDisable) {
					this.downloadBtn.setAttribute('disabled', 'true');
				} else {
					this.downloadBtn.removeAttribute('disabled');
				}
				console.log('Download button state - disabled:', shouldDisable);
			}
		}

		// LocalStorage methods for recordings persistence
		saveRecordings() {
			try {
				// We can't save blob URLs, so we'll save recording metadata
				const recordingsToSave = this.recordings.map(recording => ({
					id: recording.id,
					timestamp: recording.timestamp.toISOString(),
					frameCount: recording.frameCount,
					fps: recording.fps,
					duration: recording.duration
				}));
				localStorage.setItem('focusDesk_recordings', JSON.stringify(recordingsToSave));
				console.log('Recordings saved to localStorage');
			} catch (error) {
				console.error('Error saving recordings:', error);
			}
		}

		loadRecordings() {
			try {
				const savedRecordings = localStorage.getItem('focusDesk_recordings');
				if (savedRecordings) {
					const recordingsData = JSON.parse(savedRecordings);
					const now = new Date();
					const threeDaysAgo = new Date(now.getTime() - (3 * 24 * 60 * 60 * 1000));

					// Only load recordings from current session that have actual video data
					// Since blob URLs don't persist across sessions, we'll only show metadata
					// for recordings from previous sessions as "expired" entries
					const currentSessionRecordings = [];
					const expiredRecordings = [];
					
					recordingsData.forEach(data => {
						const timestamp = new Date(data.timestamp);
						const recording = {
							...data,
							timestamp: timestamp,
							url: null, // URL will be null for loaded recordings
							blob: null, // Blob will be null for loaded recordings
							isExpired: true, // Mark as expired since we can't play them
							fromPreviousSession: true
						};
						expiredRecordings.push(recording);
					});
					
					// Show up to 3 expired recordings for reference, but no current session ones
					this.recordings = expiredRecordings.slice(0, 3);
					
					console.log('Loaded recordings from localStorage:', this.recordings.length);
					console.log('All recordings marked as expired due to session change');
					this.updateRecordingsList();
				}
			} catch (error) {
				console.error('Error loading recordings:', error);
			}
		}

		deleteRecording(id) {
			this.recordings = this.recordings.filter(r => r.id !== id);
			this.saveRecordings();
			this.updateRecordingsList();
			this.updateUI();
		}

		clearHistory() {
			// Remove all recordings from previous sessions
			this.recordings = this.recordings.filter(r => !r.fromPreviousSession);
			
			// Clear localStorage completely and resave only current session recordings
			localStorage.removeItem('focusDesk_recordings');
			if (this.recordings.length > 0) {
				this.saveRecordings();
			}
			
			this.updateRecordingsList();
			this.updateUI();
			console.log('Recording history cleared');
		}

		updateStatus(message) {
			console.log('Status:', message);
		}

		showCompletionPopup(recording) {
			console.log('Showing completion popup for recording:', recording.id);
			
			// Create modal overlay
			const modal = document.createElement('div');
			modal.style.cssText = `
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.8);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 9999;
				backdrop-filter: blur(8px);
			`;

			// Create popup content
			const popup = document.createElement('div');
			popup.style.cssText = `
				background: white;
				border-radius: 16px;
				padding: 32px;
				max-width: 400px;
				width: 90%;
				text-align: center;
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
				transform: scale(0.8);
				transition: transform 0.3s ease;
			`;

			popup.innerHTML = `
				<div style="margin-bottom: 24px;">
					<div style="width: 64px; height: 64px; background: #10b981; border-radius: 50%; margin: 0 auto 16px; display: flex; align-items: center; justify-content: center; font-size: 32px; color: white;">
						üéâ
					</div>
					<h2 style="margin: 0 0 8px 0; color: #111827; font-size: 24px; font-weight: bold;">
						Time-lapse Complete!
					</h2>
					<p style="margin: 0; color: #6b7280; font-size: 16px;">
						${recording.frameCount} frames ‚Ä¢ ${recording.fps}fps ‚Ä¢ ${recording.duration}s
					</p>
				</div>
				
				<div style="display: flex; gap: 12px; justify-content: center;">
					<button id="download-popup-btn" style="
						background: #3b82f6;
						color: white;
						border: none;
						padding: 12px 24px;
						border-radius: 8px;
						font-size: 16px;
						font-weight: 600;
						cursor: pointer;
						transition: all 0.2s ease;
						display: flex;
						align-items: center;
						gap: 8px;
					">
						üì• Download
					</button>
					<button id="close-popup-btn" style="
						background: #6b7280;
						color: white;
						border: none;
						padding: 12px 24px;
						border-radius: 8px;
						font-size: 16px;
						font-weight: 600;
						cursor: pointer;
						transition: all 0.2s ease;
					">
						Close
					</button>
				</div>
			`;

			// Add hover effects
			const downloadBtn = popup.querySelector('#download-popup-btn');
			const closeBtn = popup.querySelector('#close-popup-btn');
			
			downloadBtn.addEventListener('mouseenter', () => {
				downloadBtn.style.background = '#2563eb';
				downloadBtn.style.transform = 'translateY(-1px)';
			});
			
			downloadBtn.addEventListener('mouseleave', () => {
				downloadBtn.style.background = '#3b82f6';
				downloadBtn.style.transform = 'translateY(0)';
			});
			
			closeBtn.addEventListener('mouseenter', () => {
				closeBtn.style.background = '#4b5563';
			});
			
			closeBtn.addEventListener('mouseleave', () => {
				closeBtn.style.background = '#6b7280';
			});

			// Add event listeners
			downloadBtn.addEventListener('click', () => {
				this.downloadRecording(recording.id);
				modal.remove();
			});

			closeBtn.addEventListener('click', () => {
				modal.remove();
			});

			// Close on backdrop click
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					modal.remove();
				}
			});

			// Close on Escape key
			const handleKeyPress = (e) => {
				if (e.key === 'Escape') {
					modal.remove();
					document.removeEventListener('keydown', handleKeyPress);
				}
			};
			document.addEventListener('keydown', handleKeyPress);

			// Append to body and animate
			modal.appendChild(popup);
			document.body.appendChild(modal);

			// Animate popup in
			setTimeout(() => {
				popup.style.transform = 'scale(1)';
			}, 10);

			// Auto-remove after 10 seconds if not interacted with
			setTimeout(() => {
				if (document.body.contains(modal)) {
					modal.remove();
				}
			}, 10000);
		}
	}

	class FocusDesk {
		constructor() {
			// Timer state
			this.timer = null;
			this.timeRemaining = 25 * 60; // 25 minutes in seconds
			this.initialTimeSet = 25 * 60; // Track the initially set time
			this.isRunning = false;

			this.initializeElements();
			this.setupEventListeners();
			this.loadStats();
		}

		initializeElements() {
			this.updateTimerDisplay();
		}

		setupEventListeners() {
			// Timer controls
			const startBtn = document.getElementById('startBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const stopBtn = document.getElementById('stopBtn');
			const resetBtn = document.getElementById('resetBtn');
			const timerUpBtn = document.getElementById('timerUpBtn');
			const timerDownBtn = document.getElementById('timerDownBtn');
			
			if (startBtn) startBtn.addEventListener('click', () => this.startTimer());
			if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseTimer());
			if (stopBtn) stopBtn.addEventListener('click', () => this.stopTimer());
			if (resetBtn) resetBtn.addEventListener('click', () => this.resetTimer());
			if (timerUpBtn) timerUpBtn.addEventListener('click', () => this.adjustTimer(5));
			if (timerDownBtn) timerDownBtn.addEventListener('click', () => this.adjustTimer(-5));

			// Timer presets
			document.querySelectorAll('.preset-btn').forEach(btn => {
				btn.addEventListener('click', (e) => {
					const minutes = parseInt(e.target.dataset.minutes || '25');
					this.setTimer(minutes);
				});
			});

			// Notes character count
			const notesTextarea = document.querySelector('textarea');
			if (notesTextarea) {
				notesTextarea.addEventListener('input', () => {
					const charCount = document.getElementById('charCount');
					if (charCount) {
						charCount.textContent = `${notesTextarea.value.length} characters`;
					}
				});
			}
		}

		setTimer(minutes) {
			this.timeRemaining = minutes * 60;
			this.initialTimeSet = minutes * 60; // Track the initially set time
			this.updateTimerDisplay();
			if (this.isRunning) {
				this.pauseTimer();
			}
		}

		adjustTimer(minuteChange) {
			if (!this.isRunning) { // Only allow adjustment when timer is not running
				const currentMinutes = Math.ceil(this.timeRemaining / 60);
				const newMinutes = Math.max(5, currentMinutes + minuteChange); // Minimum 5 minutes
				this.setTimer(newMinutes);
			}
		}

		startTimer() {
			if (!this.isRunning) {
				this.isRunning = true;
				this.timer = setInterval(() => {
					this.timeRemaining--;
					this.updateTimerDisplay();
					
					if (this.timeRemaining <= 0) {
						this.completeSession();
					}
				}, 1000);

				this.updateControls();
				this.updateTimerStatus('Focus time! Stay concentrated.');
			}
		}

		pauseTimer() {
			if (this.isRunning && this.timer) {
				this.isRunning = false;
				clearInterval(this.timer);
				this.timer = null;
				this.updateControls();
				this.updateTimerStatus('Timer paused');
			}
		}

		stopTimer() {
			if (this.isRunning && this.timer) {
				this.completeSession();
			}
		}

		resetTimer() {
			if (this.timer) {
				clearInterval(this.timer);
				this.timer = null;
			}
			this.isRunning = false;
			this.timeRemaining = 25 * 60;
			this.initialTimeSet = 25 * 60; // Reset initial time tracking
			this.updateTimerDisplay();
			this.updateControls();
			this.updateTimerStatus('Ready to start');
		}

		completeSession() {
			if (this.timer) {
				clearInterval(this.timer);
				this.timer = null;
			}
			this.isRunning = false;
			this.updateControls();
			
			// Check if session was completed (timer reached 0) or manually stopped
			const wasCompleted = this.timeRemaining <= 0;
			
			if (wasCompleted) {
				this.updateTimerStatus('Session completed! Great work! üéâ');
				this.incrementStats();
				
				// Show completion notification
				if (Notification.permission === 'granted') {
					new Notification('Focus Session Complete!', {
						body: 'Great job! You completed your focus session.',
						icon: '/favicon.ico'
					});
				}
			} else {
				this.updateTimerStatus('Session ended early. Still counts as progress! üí™');
				this.incrementStats(); // Still count partial sessions
			}
		}

		updateTimerDisplay() {
			const minutes = Math.floor(this.timeRemaining / 60);
			const seconds = this.timeRemaining % 60;
			const display = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
			
			const timerDisplay = document.getElementById('timerDisplay');
			if (timerDisplay) {
				timerDisplay.textContent = display;
			}
		}

		updateTimerStatus(status) {
			const statusElement = document.getElementById('timerStatus');
			if (statusElement) {
				statusElement.textContent = status;
			}
		}

		updateControls() {
			const startBtn = document.getElementById('startBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const stopBtn = document.getElementById('stopBtn');
			
			if (startBtn && pauseBtn && stopBtn) {
				startBtn.disabled = this.isRunning;
				pauseBtn.disabled = !this.isRunning;
				stopBtn.disabled = !this.isRunning;
			}
		}

		loadStats() {
			const today = new Date().toDateString();
			const lastActiveDate = localStorage.getItem('focusDesk_lastActiveDate');
			
			// Check if it's a new day and reset today's progress (but keep streak)
			if (lastActiveDate && lastActiveDate !== today) {
				// Reset today's progress for the new day
				localStorage.removeItem('focusDesk_todayFocusTime');
				localStorage.removeItem('focusDesk_todaySessions');
				console.log('New day detected - reset today\'s progress');
			}
			
			// Check if streak should be reset
			let currentStreak = parseInt(localStorage.getItem('focusDesk_currentStreak') || '0');
			
			if (lastActiveDate) {
				const lastDate = new Date(lastActiveDate);
				const todayDate = new Date(today);
				const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
				
				if (daysDiff > 1) {
					// More than 1 day gap, reset streak
					currentStreak = 0;
					localStorage.setItem('focusDesk_currentStreak', '0');
				}
			}

			// Load stats from localStorage or set defaults
			const stats = {
				sessionsCompleted: this.getTodaySessions(), // Show today's sessions in the display
				totalFocusTime: this.getTodayFocusTime(), // Show today's focus time
				currentStreak: currentStreak,
				todaySessions: this.getTodaySessions()
			};

			this.updateStatsDisplay(stats);
		}

		getTodayFocusTime() {
			const today = new Date().toDateString();
			const todayFocusData = localStorage.getItem('focusDesk_todayFocusTime');
			
			if (todayFocusData) {
				const data = JSON.parse(todayFocusData);
				if (data.date === today) {
					return data.time;
				}
			}
			return 0;
		}

		getTodaySessions() {
			const today = new Date().toDateString();
			const todaySessionsData = localStorage.getItem('focusDesk_todaySessions');
			
			if (todaySessionsData) {
				const data = JSON.parse(todaySessionsData);
				if (data.date === today) {
					return data.count;
				}
			}
			return 0;
		}

		incrementStats() {
			const today = new Date().toDateString();
			const lastActiveDate = localStorage.getItem('focusDesk_lastActiveDate');
			
			// Calculate actual focus time completed (in minutes)
			const actualFocusTime = Math.ceil((this.initialTimeSet - this.timeRemaining) / 60);
			
			// Update today's sessions
			const todaySessions = this.getTodaySessions() + 1;
			localStorage.setItem('focusDesk_todaySessions', JSON.stringify({
				date: today,
				count: todaySessions
			}));

			// Update today's focus time
			const todayFocusTime = this.getTodayFocusTime() + actualFocusTime;
			localStorage.setItem('focusDesk_todayFocusTime', JSON.stringify({
				date: today,
				time: todayFocusTime
			}));

			// Handle streak logic
			let currentStreak = parseInt(localStorage.getItem('focusDesk_currentStreak') || '0');
			
			if (lastActiveDate) {
				const lastDate = new Date(lastActiveDate);
				const todayDate = new Date(today);
				const daysDiff = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
				
				if (daysDiff === 1) {
					// Consecutive day, increment streak
					currentStreak += 1;
				} else if (daysDiff === 0) {
					// Same day, keep streak (don't increment)
				} else {
					// Gap in days, start new streak
					currentStreak = 1;
				}
			} else {
				// First time, start streak
				currentStreak = 1;
			}

			const currentStats = {
				sessionsCompleted: todaySessions, // Show today's sessions
				totalFocusTime: todayFocusTime, // Show today's focus time
				currentStreak: currentStreak,
				todaySessions: todaySessions
			};

			// Update global totals (for achievements and overall tracking)
			const globalSessions = parseInt(localStorage.getItem('focusDesk_globalSessions') || '0') + 1;
			const globalFocusTime = parseInt(localStorage.getItem('focusDesk_globalFocusTime') || '0') + actualFocusTime;
			localStorage.setItem('focusDesk_globalSessions', globalSessions.toString());
			localStorage.setItem('focusDesk_globalFocusTime', globalFocusTime.toString());

			// Save other data to localStorage
			localStorage.setItem('focusDesk_currentStreak', currentStats.currentStreak.toString());
			localStorage.setItem('focusDesk_lastActiveDate', today);

			this.updateStatsDisplay(currentStats);
			
			// Show achievement notifications based on global stats
			this.showAchievements({
				...currentStats,
				sessionsCompleted: globalSessions,
				totalFocusTime: globalFocusTime
			});
		}

		showAchievements(stats) {
			// Show achievement notifications for milestones
			if (stats.sessionsCompleted % 10 === 0) {
				this.showNotification(`üéâ Milestone reached! ${stats.sessionsCompleted} sessions completed!`);
			}
			
			if (stats.currentStreak === 7) {
				this.showNotification(`üî• Amazing! You've got a 7-day streak!`);
			} else if (stats.currentStreak === 30) {
				this.showNotification(`üèÜ Incredible! 30-day streak achieved!`);
			} else if (stats.currentStreak > 0 && stats.currentStreak % 5 === 0) {
				this.showNotification(`‚≠ê Great job! ${stats.currentStreak}-day streak!`);
			}
		}

		showNotification(message) {
			if (Notification.permission === 'granted') {
				new Notification('Focus Desk Achievement!', {
					body: message,
					icon: '/favicon.ico'
				});
			}
		}

		updateStatsDisplay(stats) {
			const sessionsElement = document.getElementById('sessionsCompleted');
			const focusTimeElement = document.getElementById('totalFocusTime');
			const streakElement = document.getElementById('currentStreak');

			if (sessionsElement) sessionsElement.textContent = stats.sessionsCompleted.toString();
			if (focusTimeElement) focusTimeElement.textContent = `${stats.totalFocusTime}m`;
			if (streakElement) streakElement.textContent = stats.currentStreak.toString();
		}
	}

	// Initialize when DOM is loaded
	document.addEventListener('DOMContentLoaded', () => {
		console.log('DOM loaded, initializing...');
		
		// Initialize blob cursor
		try {
			initBlobCursor();
			console.log('BlobCursor initialized');
		} catch (error) {
			console.error('Error initializing BlobCursor:', error);
		}
		
		try {
			window.timeLapse = new TimeLapseRecorder();
			console.log('TimeLapseRecorder initialized');
		} catch (error) {
			console.error('Error initializing TimeLapseRecorder:', error);
		}
		
		try {
			window.focusDesk = new FocusDesk();
			console.log('FocusDesk initialized');
		} catch (error) {
			console.error('Error initializing FocusDesk:', error);
		}
		
		// Request notification permission
		if ('Notification' in window && Notification.permission === 'default') {
			Notification.requestPermission();
		}
	});
</script>
